import { LRParser } from '@lezer/lr';
import { LRLanguage, indentNodeProp, delimitedIndent, foldNodeProp, foldInside, LanguageSupport, syntaxTree } from '@codemirror/language';
import { styleTags, tags } from '@lezer/highlight';

// This file was generated by lezer-generator. You probably shouldn't edit it.
const parser = LRParser.deserialize({
    version: 14,
    states: "nOVQPOOOOQO'#Cf'#CfOOQO'#Cc'#CcQVQPOOOOQO-E6a-E6a",
    stateData: "e~OPOS~ORPOSPOTPOUPO~O",
    goto: "fZPPPPPPP[PPbQRORSRTQOR",
    nodeNames: "âš  Whitespace Program Identifier String Boolean Keyword",
    maxTerm: 10,
    skippedNodes: [0, 1],
    repeatNodeCount: 1,
    tokenData: "IX~RwX^#lpq#lrs$awx$r}!O%O!Q![%O!c!d%d!d!e%O!e!f'r!f!g%O!g!h)j!h!i1W!i!j%O!j!k2x!k!n%O!n!o8e!o!q%O!q!r:n!r!t%O!t!u=f!u!w%O!w!x>l!x!y@^!y!zBj!z!}%O#R#S%O#T#Y%O#Y#ZEb#Z#h%O#h#iHR#i#o%O#y#z#l$f$g#l#BY#BZ#l$IS$I_#l$I|$JO#l$JT$JU#l$KV$KW#l&FU&FV#l~#qYP~X^#lpq#l#y#z#l$f$g#l#BY#BZ#l$IS$I_#l$I|$JO#l$JT$JU#l$KV$KW#l&FU&FV#l~$dROr$ars$ms~$a~$rOS~~$uROw$rwx$mx~$r~%TTR~}!O%O!Q![%O!c!}%O#R#S%O#T#o%O~%iXR~}!O%O!Q![%O!c!f%O!f!g&U!g!t%O!t!u'W!u!}%O#R#S%O#T#o%O~&ZVR~}!O%O!Q![%O!c!f%O!f!g&p!g!}%O#R#S%O#T#o%O~&wTU~R~}!O%O!Q![%O!c!}%O#R#S%O#T#o%O~']VR~}!O%O!Q![%O!c!i%O!i!j&p!j!}%O#R#S%O#T#o%O~'wXR~}!O%O!Q![%O!c!o%O!o!p&U!p!q%O!q!r(d!r!}%O#R#S%O#T#o%O~(iVR~}!O%O!Q![%O!c!r%O!r!s)O!s!}%O#R#S%O#T#o%O~)TVR~}!O%O!Q![%O!c!{%O!{!|&p!|!}%O#R#S%O#T#o%O~)oXR~}!O%O!Q![%O!c!p%O!p!q*[!q!z%O!z!{.z!{!}%O#R#S%O#T#o%O~*aXR~}!O%O!Q![%O!c!v%O!v!w*|!w!x%O!x!y&p!y!}%O#R#S%O#T#o%O~+RVR~}!O%O!Q![%O!c!t%O!t!u+h!u!}%O#R#S%O#T#o%O~+mVR~}!O%O!Q![%O!c!{%O!{!|,S!|!}%O#R#S%O#T#o%O~,XVR~}!O%O!Q![%O!c!r%O!r!s,n!s!}%O#R#S%O#T#o%O~,sVR~}!O%O!Q![%O!c!q%O!q!r-Y!r!}%O#R#S%O#T#o%O~-_VR~}!O%O!Q![%O!c!k%O!k!l-t!l!}%O#R#S%O#T#o%O~-yVR~}!O%O!Q![%O!c!p%O!p!q.`!q!}%O#R#S%O#T#o%O~.eVR~}!O%O!Q![%O!c!v%O!v!w&p!w!}%O#R#S%O#T#o%O~/PVR~}!O%O!Q![%O!c!r%O!r!s/f!s!}%O#R#S%O#T#o%O~/kVR~}!O%O!Q![%O!c!q%O!q!r0Q!r!}%O#R#S%O#T#o%O~0VVR~}!O%O!Q![%O!c!u%O!u!v0l!v!}%O#R#S%O#T#o%O~0qVR~}!O%O!Q![%O!c!g%O!g!h&p!h!}%O#R#S%O#T#o%O~1]VR~}!O%O!Q![%O!c!t%O!t!u1r!u!}%O#R#S%O#T#o%O~1wVR~}!O%O!Q![%O!c!q%O!q!r2^!r!}%O#R#S%O#T#o%O~2cVR~}!O%O!Q![%O!c!o%O!o!p&p!p!}%O#R#S%O#T#o%O~2}VR~}!O%O!Q![%O!c!g%O!g!h3d!h!}%O#R#S%O#T#o%O~3iUR~}!O%O!Q![%O!c!d3{!d!}%O#R#S%O#T#o%O~4QVR~}!O%O!Q![%O!c!n%O!n!o4g!o!}%O#R#S%O#T#o%O~4lVR~}!O%O!Q![%O!c!v%O!v!w5R!w!}%O#R#S%O#T#o%O~5WVR~}!O%O!Q![%O!c!j%O!j!k5m!k!}%O#R#S%O#T#o%O~5rVR~}!O%O!Q![%O!c!e%O!e!f6X!f!}%O#R#S%O#T#o%O~6^VR~}!O%O!Q![%O!c!j%O!j!k6s!k!}%O#R#S%O#T#o%O~6xVR~}!O%O!Q![%O!c!g%O!g!h7_!h!}%O#R#S%O#T#o%O~7dVR~}!O%O!Q![%O!c!e%O!e!f7y!f!}%O#R#S%O#T#o%O~8OVR~}!O%O!Q![%O!c!m%O!m!n&p!n!}%O#R#S%O#T#o%O~8jUR~}!O%O!Q![%O!c!d8|!d!}%O#R#S%O#T#o%O~9RVR~}!O%O!Q![%O!c!d%O!d!e9h!e!}%O#R#S%O#T#o%O~9mVR~}!O%O!Q![%O!c!g%O!g!h:S!h!}%O#R#S%O#T#o%O~:XVR~}!O%O!Q![%O!c!n%O!n!o&p!o!}%O#R#S%O#T#o%O~:sVR~}!O%O!Q![%O!c!p%O!p!q;Y!q!}%O#R#S%O#T#o%O~;_VR~}!O%O!Q![%O!c!d%O!d!e;t!e!}%O#R#S%O#T#o%O~;yVR~}!O%O!Q![%O!c!w%O!w!x<`!x!}%O#R#S%O#T#o%O~<eVR~}!O%O!Q![%O!c!k%O!k!l<z!l!}%O#R#S%O#T#o%O~=PVR~}!O%O!Q![%O!c!n%O!n!o&U!o!}%O#R#S%O#T#o%O~=kVR~}!O%O!Q![%O!c!w%O!w!x>Q!x!}%O#R#S%O#T#o%O~>VVR~}!O%O!Q![%O!c!p%O!p!q&p!q!}%O#R#S%O#T#o%O~>qVR~}!O%O!Q![%O!c!u%O!u!v?W!v!}%O#R#S%O#T#o%O~?]VR~}!O%O!Q![%O!c!g%O!g!h?r!h!}%O#R#S%O#T#o%O~?wVR~}!O%O!Q![%O!c!t%O!t!u&p!u!}%O#R#S%O#T#o%O~@cVR~}!O%O!Q![%O!c!q%O!q!r@x!r!}%O#R#S%O#T#o%O~@}VR~}!O%O!Q![%O!c!n%O!n!oAd!o!}%O#R#S%O#T#o%O~AiVR~}!O%O!Q![%O!c!w%O!w!xBO!x!}%O#R#S%O#T#o%O~BTVR~}!O%O!Q![%O!c!o%O!o!p0l!p!}%O#R#S%O#T#o%O~BoVR~}!O%O!Q![%O!c!q%O!q!rCU!r!}%O#R#S%O#T#o%O~CZVR~}!O%O!Q![%O!c!t%O!t!uCp!u!}%O#R#S%O#T#o%O~CuVR~}!O%O!Q![%O!c!m%O!m!nD[!n!}%O#R#S%O#T#o%O~DaVR~}!O%O!Q![%O!c!f%O!f!gDv!g!}%O#R#S%O#T#o%O~D{VR~}!O%O!Q![%O!c!k%O!k!l?r!l!}%O#R#S%O#T#o%O~EgUR~}!O%O!Q![%O!c!}%O#R#S%O#T#UEy#U#o%O~FOVR~}!O%O!Q![%O!c!}%O#R#S%O#T#`%O#`#aFe#a#o%O~FjVR~}!O%O!Q![%O!c!}%O#R#S%O#T#g%O#g#hGP#h#o%O~GUVR~}!O%O!Q![%O!c!}%O#R#S%O#T#X%O#X#YGk#Y#o%O~GrTT~R~}!O%O!Q![%O!c!}%O#R#S%O#T#o%O~HWVR~}!O%O!Q![%O!c!}%O#R#S%O#T#f%O#f#gHm#g#o%O~HrVR~}!O%O!Q![%O!c!}%O#R#S%O#T#i%O#i#jGP#j#o%O",
    tokenizers: [0],
    topRules: { "Program": [0, 2] },
    tokenPrec: 0
});

const EXAMPLELanguage = LRLanguage.define({
    parser: parser.configure({
        props: [
            indentNodeProp.add({
                Application: delimitedIndent({ closing: "\n", align: true })
            }),
            foldNodeProp.add({
                Application: foldInside
            }),
            styleTags({
                Keyword: tags.keyword,
                Identifier: tags.variableName,
                Boolean: tags.bool,
                String: tags.string,
                LineComment: tags.lineComment,
                Comment: tags.comment
            })
        ]
    })
});
const keywords = ['FROM', 'RUN', 'COPY', 'ADD', 'CMD', 'ENTRYPOINT', 'ENV', 'ARG', 'VOLUME', 'EXPOSE', 'WORKDIR', 'USER', 'HEALTHCHECK', 'ONBUILD', 'LABEL', 'SHELL', 'STOPSIGNAL'].map(name => ({ type: "keyword", label: name }));
function EXAMPLE() {
    const completionSource = (context) => {
        const { state, pos } = context, node = syntaxTree(state).resolveInner(pos, -1);
        console.log(node);
        return { from: node.from, options: keywords, validFor: /^[\w-]*/ };
    };
    return new LanguageSupport(EXAMPLELanguage, EXAMPLELanguage.data.of({ autocomplete: completionSource }));
}

export { EXAMPLE, EXAMPLELanguage };
